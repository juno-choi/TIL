# 🔴 전략적 설계

## 🟠 도메인 분석하기

시스템은 하나의 도메인이 아닌 여러개의 도메인으로 나눌 수 있다.

도메인에 따라 핵심 인력을 배치해야 할지 혹은 외주 or 솔루션 사용 등의 전략적인 결정을 할 수 있다.

### 🟢 핵심 도메인

- 회사에서 가장 핵심이 되는 도메인
- 직접 개발해야만 함
- 타사와 차별화되는 경쟁력이 되는 부분

### 🟢 일반 도메인

- 모든 회사에서 공통적으로 사용하고 있는 부분
- 모든 서비스에서 공통적으로 요구하는 사항
- 로그인, 알람, 권한 관리 등

### 🟢 지원 도메인

- 핵심 도메인을 보조하는 역할
- 없으면 핵심 도메인이 돌아가기 어렵지만 직접 개발하지 않고 솔루션을 사용해되는 부분
- 핵심 도메인이 만약 쇼핑몰이라면 고객 관리, 배송 추적 등
- 회사 경쟁력은 아니지만 꼭 필요한 영역

## 🟠 도메인 지식 찾아내기

비즈니스 전문가와 개발자, 기획자, 디자이너 등 다양한 사람들과 협업을 하면서 도메인에 대한 용어는 같은 언어로 사용해야 한다.

### 🟢 유비쿼터스 언어(Ubiquitous Language)

- 비즈니스에 참가하는 모든 인원은 같은 언어를 써야 한다는 개념
- 예를 들어 `주문`이라는 단어를 사업에서는 `구매 요청`으로 사용하고 개발자는 `order` 이라는 단어로 사용한다면 커뮤니케이션에 있어 문제가 발생할 수 있음 
- 이러한 문제를 해결하기 위해 도메인 용어 사전(glossary)을 만들어 공유하고 코드, 문서, 대화에 동일하게 사용해야 한다

## 🟠 도메인 복잡성 관리

도메인의 크기가 증가함에 따라 용어들이 겹치기도 하고 같은 용어가 의미적으로 다른 경우가 존재하기 시작한다.

이러한 도메인 복잡성을 관리할 수 있어야 한다.

### 🟢 경계 컨텍스트(Bounded Context)

- 하위 도메인을 감싹는 경계
- 경계에 따라 같은 단어라도 다른 의미로 사용될 수 있다.
- 예를 들어 `고객` 이란 단어는 마케팅에서는 `푸시 대상자`로 사업에서는 `구매자`로, CS에서는 `상담 이력이 있는 대상자`로 구분될 수 있다. 또한 개발에서는 `User 테이블에 존재하는 대상자`로 생각할 수 있다.
- 서로 다른 컨텍스트에서는 같은 단어라도 의미가 다를 수 있다.
- 하나의 Bounded Context 안에서는 유비쿼터스 언어가 일관되게 사용되어야 한다.
- 경계를 명확히 그려 혼돈되는 상황이 없도록 한다.

## 🟠 바운디드 컨텍스트 연동

### 🟢 Context Map
![img.png](image/part1/context%20map.png)

- Bounded Context를 시각화 하여 관계들을 표현한 지도
- 관계 사이에 패턴(OHS, ACL 등)을 라벨로 표시

### 🟢 연동 패턴들

| 패턴                                | 관계 특징                         | 언제 쓰는가                        | 장점             | 단점/주의점                | 예시                         |
| --------------------------------- | ----------------------------- | ----------------------------- | -------------- | --------------------- | -------------------------- |
| **Shared Kernel**<br>(공유 커널)      | 두 BC가 **일부 모델**을 공유           | 동일한 모델을 여러 컨텍스트에서 동일하게 써야 할 때 | 중복 방지          | 결합도가 높아지고 변경이 어려움     | `회원ID`를 주문과 결제에서 공유        |
| **Customer–Supplier**<br>(고객–공급자) | 한쪽(고객)이 다른 쪽(공급자)의 API/모델을 사용 | 공급자가 안정적인 계약을 보장할 수 있을 때      | 협업 관계가 명확      | 공급자 변경이 어렵거나 불안정하면 위험 | `배송` → `주문` API 사용         |
| **Conformist**<br>(순응자)           | 공급자가 강력, 고객이 따를 수밖에 없음        | 외부 시스템이 주도권을 쥔 경우             | 빠른 연동 가능       | 내부 언어/모델이 오염됨         | 외부 PG사 API를 그대로 사용         |
| **Anti-Corruption Layer (ACL)**   | 중간 계층에서 변환/적응                 | 외부 모델을 우리 언어로 보호하고 싶을 때       | 도메인 순수성 유지     | 구현 비용이 추가됨            | `PG사 응답` → `결제 도메인 모델` 변환  |
| **Open Host Service (OHS)**       | 한 컨텍스트가 **공개 API 계약** 제공      | 여러 컨텍스트가 접근해야 할 때             | 계약이 명확, 재사용성 ↑ | API 유지보수 필요           | `주문 조회 API`를 REST/gRPC로 공개 |

### 🟢 패턴 요약

패턴들은 처음엔 이해하기가 어려워 좀 더 쉽게 풀어 써보려고 한다

`Shared Kernel` → "같이 쓰자"

`Customer–Supplier` → "내가 줄 테니 써"

`Conformist` → "싫어도 따를 수밖에"

`ACL` → "중간에서 번역해줄게"

`OHS` → "공식 문 열어둘게, 규칙 지켜서 들어와"