# 🔴 좋은 시스템 설계에 대해 내가 아는 모든 것
잘못된 시스템 설계 조언을 많이 봅니다. 그중 하나는 LinkedIn에 최적화된 " 큐 는 들어본 적도 없을 거야 " 스타일의 게시물인데, 아마도 업계 신입생을 겨냥한 것 같습니다. 또 다른 하나는 Twitter에 최적화된 "데이터베이스에 불리언을 저장하면 형편없는 엔지니어가 될 거야"라는 영리한 속임수입니다 . 좋은 시스템 설계 조언조차도 다소 나쁠 수 있습니다. 저는 "데이터 집약적 애플리케이션 설계"라는 책을 좋아 하지만, 엔지니어들이 직면하게 될 대부분의 시스템 설계 문제에는 그다지 유용하지 않다고 생각합니다.

시스템 설계란 무엇일까요? 제 생각에 소프트웨어 설계가 코드를 어떻게 조립하는지라면, 시스템 설계는 서비스를 어떻게 조립하는지입니다 . 소프트웨어 설계의 기본 요소는 변수, 함수, 클래스 등입니다. 시스템 설계의 기본 요소는 앱 서버, 데이터베이스, 캐시, 큐, 이벤트 버스, 프록시 등입니다.

이 글은 좋은 시스템 설계에 대해 제가 아는 모든 것을 간략하게 정리해 보려는 시도입니다. 구체적인 판단은 대부분 경험에서 비롯되는데, 이 글에서 다 전달하기는 어렵습니다. 하지만 제가 할 수 있는 한 최대한 적어보려고 합니다.

## 🟠 좋은 디자인 인식하기
좋은 시스템 설계는 어떤 모습일까요? 전에도 그런 설계는 별로라고 쓴 적이 있습니다 . 실제로는 오랫동안 아무 문제 없어 보입니다. "어머, 생각보다 쉬웠네" 또는 "시스템의 이 부분에 대해 생각할 필요가 없네, 괜찮아"와 같은 생각이 든다면 좋은 설계가 있다는 것을 알 수 있습니다. 역설적이게도 좋은 설계는 자기 부각을 잘 하지 않습니다. 나쁜 설계는 좋은 설계보다 더 인상적인 경우가 많습니다. 저는 인상 깊은 시스템은 항상 의심스럽습니다. 시스템에 분산 합의 메커니즘, 다양한 이벤트 기반 통신 방식, CQRS, 그리고 다른 영리한 기법들이 있다면, 근본적으로 잘못된 결정이 보상받고 있는 것은 아닌지(아니면 시스템이 단순히 과도하게 설계된 것은 아닌지) 궁금합니다.

저는 종종 이 문제에 대해 혼자 생각합니다. 엔지니어들은 흥미로운 부분이 많은 복잡한 시스템을 보고 "와, 정말 많은 시스템 설계가 이뤄지고 있네!"라고 생각합니다. 사실 복잡한 시스템은 대개 좋은 설계가 부족함을 나타냅니다. "대개"라고 말하는 이유는 복잡한 시스템이 필요할 때가 있기 때문입니다. 저는 복잡성을 감수할 만한 많은 시스템을 작업해 왔습니다. 하지만 제대로 작동하는 복잡한 시스템은 항상 작동하는 단순한 시스템에서 발전합니다. 복잡한 시스템을 처음부터 시작하는 것은 정말 잘못된 생각입니다.

## 🟠 국가와 무국적
소프트웨어 설계에서 가장 어려운 부분은 상태입니다. 어떤 종류의 정보든 얼마든지 저장하고 있다면, 저장, 제공 방식에 대해 여러 가지 까다로운 결정을 내려야 합니다. 정보를 저장하지 않는다면 앱 은 "상태 비저장(stateless)" 상태가 됩니다. 간단한 예로, GitHub에는 PDF 파일을 받아서 HTML로 렌더링하여 반환하는 내부 API가 있습니다. 이것이 바로 진정한 상태 비저장 서비스입니다. 데이터베이스에 쓰는 모든 것은 상태를 유지합니다.

모든 시스템에서 상태 저장 구성 요소의 양을 최소화하려고 해야 합니다.(어떤 의미에서는 사소한 사실인데, 시스템의 모든 구성 요소의 양을 최소화하려고 해야 하지만 상태 저장 구성 요소는 특히 위험합니다.) 이렇게 해야 하는 이유는 상태 저장 구성 요소가 나쁜 상태가 될 수 있기 때문입니다 . 상태 없는 PDF 렌더링 서비스는 광범위하게 합리적인 작업을 수행하는 한 영원히 안전하게 실행됩니다.예를 들어, 문제가 발생할 경우 자동으로 종료하고 작동 순서로 복원할 수 있도록 재시작 가능한 컨테이너에서 실행합니다.상태 저장 서비스는 이와 같이 자동으로 복구할 수 없습니다.데이터베이스에 잘못된 항목이 추가되면(예: 애플리케이션에서 충돌을 유발하는 형식이 있는 항목) 수동으로 들어가서 수정해야 합니다.데이터베이스 공간이 부족하면 불필요한 데이터를 정리하거나 확장할 방법을 찾아야 합니다.

실제로 이는 상태를 알고 있는 서비스 하나(즉, 데이터베이스와 통신하는 서비스)와 상태 비저장 작업을 수행하는 다른 서비스 하나를 갖는 것을 의미합니다. 다섯 개의 서로 다른 서비스가 모두 같은 테이블에 쓰기 작업을 하는 것은 피하세요. 대신, 네 개의 서비스가 첫 번째 서비스로 API 요청을 보내거나 이벤트를 발생시키도록 하고, 쓰기 로직은 해당 서비스 내에서 처리하도록 하세요. 가능하다면 읽기 로직에도 이렇게 하는 것이 좋지만, 저는 이 부분에 대해 그다지 엄격하지는 않습니다. 서비스가 내부 세션 서비스에 두 배 느린 HTTP 요청을 하는 것보다 테이블을 빠르게 읽는 것이 더 나을 때가user_sessions 있습니다 .

## 🟠 데이터베이스
상태 관리는 시스템 설계에서 가장 중요한 부분이기 때문에, 가장 중요한 구성 요소는 대개 상태가 저장되는 곳, 즉 데이터베이스입니다. 저는 대부분의 시간을 SQL 데이터베이스(MySQL과 PostgreSQL)를 다루는 데 투자해 왔기 때문에, 이 글에서는 SQL 데이터베이스에 대해 이야기해 보겠습니다.

### 🟢 스키마와 인덱스
데이터베이스에 무언가를 저장해야 한다면, 가장 먼저 해야 할 일은 필요한 스키마를 가진 테이블을 정의하는 것입니다. 스키마 설계는 유연해야 합니다. 수천 또는 수백만 개의 레코드가 생기면 스키마를 변경하는 것이 엄청나게 번거로울 수 있기 때문입니다. 하지만 스키마를 너무 유연하게 만들면(예: 모든 것을 "값" JSON 열에 담거나, "키" 및 "값" 테이블을 사용하여 임의의 데이터를 추적하는 경우) 애플리케이션 코드에 엄청난 복잡성을 더하게 되고, 매우 까다로운 성능 제약 조건을 초래할 가능성이 높습니다. 여기서 한계를 정하는 것은 개인적인 판단이며 구체적인 사항에 따라 달라지지만, 일반적으로 저는 테이블이 사람이 읽을 수 있도록 만드는 것을 목표로 합니다. 데이터베이스 스키마를 살펴보면 애플리케이션이 무엇을 왜 저장하는지 대략적으로 파악할 수 있어야 합니다.

테이블의 행 수가 몇 개 이상일 것으로 예상되는 경우 인덱스를 생성해야 합니다. 가장 자주 전송하는 쿼리와 일치하는 인덱스를 생성해 보세요(예: 와 로 쿼리하는 경우 email, type두 필드로 인덱스를 생성). 인덱스는 중첩된 사전처럼 작동하므로, 카디널리티가 가장 높은 필드를 먼저 생성해야 합니다(그렇지 않으면 각 인덱스 조회 시 의 모든 사용자를 검색하여 type적절한 를 가진 필드를 찾아야 합니다 email). 인덱스를 생성할 때마다 쓰기 오버헤드가 발생하므로, 생각나는 모든 것에 인덱스를 생성하지 마세요.

### 🟢 병목 현상
트래픽이 많은 애플리케이션에서 데이터베이스 접근은 종종 병목 현상의 원인이 됩니다. 이는 컴퓨팅 측면이 상대적으로 비효율적인 경우에도 마찬가지입니다(예: Unicorn과 같은 프리포킹 서버에서 Ruby on Rails를 실행하는 경우). 복잡한 애플리케이션은 수많은 데이터베이스 호출을 해야 하기 때문입니다. 각 요청마다 수백 건의 호출이 발생하며, 이는 종종 순차적으로 발생합니다(사용자가 악의적인 행위를 하지 않는지 확인하기 전까지는 해당 사용자가 조직에 속해 있는지 확인해야 하는지 알 수 없기 때문입니다). 병목 현상을 어떻게 방지할 수 있을까요?

데이터베이스에 쿼리를 실행할 때는 데이터베이스를 쿼리하세요 . 직접 작업하는 것보다 데이터베이스가 작업을 처리하도록 하는 것이 거의 항상 더 효율적입니다. 예를 들어 여러 테이블의 데이터가 필요한 경우, 별도의 쿼리를 작성하여 메모리 내에서 연결하는 대신 여러 테이블에서 데이터를 가져오세요. 특히 ORM을 사용하는 경우, 실수로 내부 루프에서 쿼리를 실행하지 않도록 주의하세요. 이렇게 하면 a를 a로, a를 a로 , a를 a로 , a를 a로 JOIN바꾸는 간단한 방법이 됩니다 .select id, name from tableselect id from tableselect name from table where id = ?

가끔 쿼리를 분리하고 싶을 때가 있습니다. 자주 있는 일은 아니지만, 데이터베이스에서 단일 쿼리로 실행하는 것보다 분리하는 것이 훨씬 더 쉬울 정도로 보기 흉한 쿼리를 접한 적이 있습니다. 데이터베이스가 더 잘 처리할 수 있도록 인덱스와 힌트를 구성하는 것은 항상 가능하지만, 가끔 전략적으로 쿼리를 분리하는 것도 유용한 도구입니다.

데이터베이스 복제본에 최대한 많은 읽기 쿼리를 전송하세요. 일반적인 데이터베이스 설정은 하나의 쓰기 노드와 여러 개의 읽기 복제본으로 구성됩니다. 쓰기 노드에서 읽기 작업을 최대한 줄일수록 좋습니다. 쓰기 노드는 이미 모든 쓰기 작업을 충분히 수행하고 있기 때문입니다. 단, 복제 지연을 정말 용납할 수 없는 경우는 예외입니다(읽기 복제본은 항상 쓰기 노드보다 최소 몇 밀리초 이상 뒤처져 있기 때문입니다). 하지만 대부분의 경우 복제 지연은 간단한 방법으로 해결할 수 있습니다. 예를 들어 레코드를 업데이트했지만 바로 사용해야 하는 경우, 쓰기 작업 후 바로 다시 읽는 대신 업데이트된 정보를 메모리에 저장할 수 있습니다.

쿼리(특히 쓰기 쿼리, 특히 트랜잭션) 급증에 주의하세요 . 데이터베이스가 과부하되면 속도가 느려지고, 이는 더 큰 과부하로 이어집니다. 트랜잭션과 쓰기는 각 쿼리마다 많은 데이터베이스 작업이 필요하기 때문에 데이터베이스 과부하에 효과적입니다. 대량의 쿼리 급증을 유발할 수 있는 서비스(예: 대량 가져오기 API)를 설계하는 경우 쿼리 제한을 고려하세요.

## 🟠 느린 작업, 빠른 작업
서비스는 어떤 작업은 빠르게 처리해야 합니다. 사용자가 무언가(예: API 또는 웹 페이지)와 상호 작용할 때 수백 밀리초( 3) 이내에 응답을 받아야 합니다 . 하지만 서비스는 느린 다른 작업도 처리해야 합니다. 어떤 작업은 시간이 오래 걸립니다(예: 매우 큰 PDF를 HTML로 변환하는 작업). 이러한 작업의 일반적인 패턴은 사용자에게 유용한 작업을 수행하는 데 필요한 최소한의 작업만 분할 하고 나머지 작업은 백그라운드에서 처리하는 것입니다. PDF-HTML 변환 예제에서 첫 번째 페이지를 즉시 HTML로 렌더링하고 나머지는 백그라운드 작업에 대기시킬 수 있습니다.

백그라운드 작업이란 무엇일까요? "백그라운드 작업"은 핵심 시스템 설계의 기본 요소이므로 자세히 설명할 가치가 있습니다. 모든 기술 회사는 백그라운드 작업을 실행하기 위한 시스템을 갖추고 있습니다. 두 가지 주요 구성 요소가 있습니다. Redis와 같은 큐 모음과 큐에서 항목을 가져와 실행하는 작업 실행기 서비스입니다. 항목을 큐 {job_name, params}에 추가하면 백그라운드 작업이 큐에 추가됩니다. 또한, 백그라운드 작업이 정해진 시간에 실행되도록 예약할 수도 있습니다(주기적인 정리 또는 요약 롤업에 유용). 백그라운드 작업은 일반적으로 매우 익숙한 방식이기 때문에 느린 작업의 경우 가장 먼저 선택해야 합니다.

때로는 자체 큐 시스템을 구축하고 싶을 수 있습니다. 예를 들어, 한 달 후에 실행할 작업을 큐에 추가하려면 Redis 큐에 항목을 추가하지 않는 것이 좋습니다. Redis의 지속성은 일반적으로 해당 기간 동안 보장되지 않습니다(그리고 보장된다 하더라도, Redis 작업 큐에서는 어려울 수 있는 방식으로 먼 미래에 추가될 작업을 쿼리할 수 있어야 합니다). 이 경우, 일반적으로 보류 중인 작업에 대한 데이터베이스 테이블을 생성하고 각 매개변수에 대한 열과 scheduled_at열을 하나씩 추가합니다. 그런 다음 일별 작업을 사용하여 이러한 항목을 확인하고 scheduled_at <= today, 작업이 완료되면 삭제하거나 완료로 표시합니다.

## 🟠 캐싱
때로는 사용자 간에 동일한 비용이 많이 드는(즉, 느린) 작업을 수행해야 하기 때문에 작업이 느립니다.예를 들어, 청구 서비스에서 사용자에게 청구할 금액을 계산하는 경우 현재 가격을 조회하기 위해 API 호출을 해야 할 수 있습니다.사용자에게 사용량 기준으로 요금을 청구하는 경우(OpenAI가 토큰 단위로 하는 것처럼) (a) 허용할 수 없을 정도로 느리고 (b) 가격을 제공하는 서비스에 많은 트래픽이 발생할 수 있습니다.이때의 기존 솔루션은 캐싱 입니다 .5분마다 가격을 조회하고 그 사이에 값을 저장합니다.메모리 내에서 캐싱하는 것이 가장 쉽지만 Redis나 Memcached와 같은 빠른 외부 키-값 저장소를 사용하는 것도 인기가 있습니다(여러 앱 서버에서 하나의 캐시를 공유할 수 있기 때문).

일반적인 패턴은 초보 엔지니어가 캐싱에 대해 배우고 모든 것을 캐시하려는 반면, 시니어 엔지니어는 가능한 한 적게 캐시하려는 것입니다. 왜 그럴까요? 이는 제가 상태 저장의 위험성에 대해 처음 언급했던 부분과 관련이 있습니다. 캐시는 상태 정보의 원천입니다. 캐시에 이상한 데이터가 들어가거나, 실제 데이터와 동기화되지 않거나, 오래된 데이터를 제공하여 알 수 없는 버그를 발생시키는 등 여러 가지 문제가 발생할 수 있습니다. 속도 향상을 위한 진지한 노력 없이는 절대 캐시해서는 안 됩니다. 예를 들어, 데이터베이스 인덱스에 포함되지 않은 값비싼 SQL 쿼리를 캐시하는 것은 어리석은 일입니다. 데이터베이스 인덱스를 추가하기만 하면 됩니다!

저는 캐싱을 많이 사용합니다. 유용한 캐싱 기법 중 하나는 예약된 작업과 S3 또는 Azure Blob Storage와 같은 문서 저장소를 대규모 영구 캐시로 사용하는 것입니다. 매우 비용이 많이 드는 작업(예: 대규모 고객의 주간 사용 보고서)의 결과를 캐싱해야 하는 경우, Redis나 Memcached에 결과를 저장하기 어려울 수 있습니다. 대신, 타임스탬프가 찍힌 결과의 Blob을 문서 저장소에 저장하고 거기에서 바로 파일을 제공하는 것이 좋습니다. 위에서 언급한 데이터베이스 기반 장기 큐와 마찬가지로, 이는 특정 캐시 기술을 사용하지 않고 캐싱 개념을 활용하는 예입니다.

## 🟠 이벤트
기술 기업은 일반적으로 캐싱 인프라와 백그라운드 작업 시스템 외에도 이벤트 허브를 사용합니다 . 가장 일반적인 구현 방식은 Kafka입니다. 이벤트 허브는 백그라운드 작업용 큐와 같은 단순한 큐입니다. 하지만 "이 작업을 다음 매개변수로 실행"을 큐에 넣는 대신 "이런 일이 발생했습니다"를 큐에 넣습니다. 한 가지 전형적인 예로, 각 새 계정에 대해 "새 계정 생성" 이벤트를 발생시킨 후 여러 서비스가 해당 이벤트를 사용하여 특정 작업을 수행하도록 하는 것입니다. 예를 들어 "환영 이메일 전송" 서비스, "악용 사례 검사" 서비스, "계정별 인프라 설정" 서비스 등이 있습니다.

이벤트를 과도하게 사용해서는 안 됩니다. 대부분의 경우 한 서비스가 다른 서비스에 API 요청을 보내는 것이 더 좋습니다. 모든 로그가 같은 곳에 있고, 추론하기도 더 쉬우며, 상대 서비스가 어떤 응답을 보냈는지 즉시 확인할 수 있습니다. 이벤트는 이벤트를 전송하는 코드가 이벤트 소비자가 이벤트를 어떻게 사용하는지 신경 쓰지 않거나, 이벤트 양이 많고 시간에 민감하지 않은 경우(예: 새로운 트위터 게시물에 대한 악용 사례 검사)에 유용합니다.

## 🟠 밀고 당기기
한 곳에서 다른 여러 곳으로 데이터를 전송해야 할 때는 두 가지 옵션이 있습니다. 가장 간단한 방법은 데이터 를 가져오는 것 입니다. 대부분의 웹사이트가 이러한 방식으로 작동합니다. 데이터를 소유한 서버가 있고, 사용자가 필요할 때 브라우저를 통해 서버에 데이터를 가져오도록 요청합니다. 문제는 사용자가 동일한 데이터를 여러 번 가져올 수 있다는 것입니다. 예를 들어, 새 이메일이 있는지 확인하기 위해 이메일 받은 편지함을 새로 고침하면 이메일 관련 데이터만 가져오는 대신 전체 웹 애플리케이션이 다시 로드됩니다.

대안은 푸시(push) 입니다 . 사용자가 데이터를 요청하도록 하는 대신, 클라이언트로 등록하도록 허용하면 데이터가 변경되면 서버가 각 클라이언트에게 데이터를 푸시합니다. Gmail의 작동 방식이 바로 이렇습니다. 새 이메일이 도착하면 바로 표시되므로, 새 이메일을 받기 위해 페이지를 새로 고칠 필요가 없습니다.

웹 브라우저를 사용하는 사용자 대신 백그라운드 서비스에 대해 이야기한다면, 푸싱이 왜 좋은 생각인지 쉽게 알 수 있습니다. 매우 큰 시스템에서도 동일한 데이터를 필요로 하는 서비스는 백 개 정도에 불과할 수 있습니다. 크게 변하지 않는 데이터의 경우, 데이터가 변경될 때마다 HTTP 요청(또는 RPC 등)을 백 개씩 보내는 것이 초당 천 번 동일한 데이터를 제공하는 것보다 훨씬 쉽습니다.

백만 명의 클라이언트(예: Gmail)에 최신 데이터를 제공해야 한다고 가정해 보겠습니다. 이 클라이언트들은 푸시를 해야 할까요, 풀을 해야 할까요? 상황에 따라 다릅니다. 어느 쪽이든 단일 서버에서 모든 작업을 실행할 수는 없으므로 시스템의 다른 구성 요소에 아웃소싱해야 합니다. 푸시를 하는 경우, 각 푸시를 이벤트 큐에 넣고, 각 큐에서 데이터를 풀링하고 푸시를 전송하는 수많은 이벤트 프로세서를 두어야 합니다. 풀을 하는 경우, 메인 애플리케이션 앞에 배치되어 모든 읽기 트래픽을 처리할 빠른 읽기 복제본 캐시 서버 ( 예 : 100대)를 여러 대 설치해야 합니다 .

## 🟠 핫 패스
시스템을 설계할 때 사용자가 시스템과 상호작용하거나 데이터를 주고받는 방식은 매우 다양합니다. 이러한 방식은 다소 부담스러울 수 있습니다. 핵심은 시스템에서 가장 중요하고 가장 많은 데이터를 처리하는 부분인 "핫 패스(hot path)"에 주로 집중하는 것입니다. 예를 들어, 종량제 요금제 시스템에서 이러한 부분은 고객에게 요금을 부과할지 여부를 결정하는 부분과 플랫폼의 모든 사용자 동작에 연동하여 요금을 책정해야 하는 부분을 구분하는 역할을 할 수 있습니다.

핫 패스는 다른 디자인 영역보다 가능한 해결책이 적기 때문에 중요합니다. 결제 설정 페이지를 구축하는 방법은 천 가지가 넘으며, 대부분 잘 작동합니다. 하지만 사용자 액션이라는 거대한 흐름을 합리적으로 활용할 수 있는 방법은 극소수에 불과할 수 있습니다. 핫 패스는 더욱 심각한 문제를 야기할 수 있습니다. 전체 제품을 다운시키려면 설정 페이지를 완전히 망가뜨려야 하지만, 모든 사용자 액션에 대해 트리거되는 코드는 쉽게 큰 문제를 일으킬 수 있습니다.

## 🟠 로깅 및 메트릭
문제가 있는지 어떻게 알 수 있나요? 가장 편집증적인 동료들에게서 배운 한 가지는 불행한 경로에서 적극적으로 로깅하는 것입니다. 사용자 대면 엔드포인트가 422에 응답해야 하는지 확인하기 위해 여러 조건을 확인하는 함수를 작성하는 경우 적중한 조건을 로그아웃해야 합니다. 청구 코드를 작성하는 경우 내린 모든 결정을 로그에 기록해야 합니다(예: "X 때문에 이 이벤트에 대한 청구를 하지 않습니다"). 많은 엔지니어가 이렇게 하지 않는 이유는 로깅 보일러플레이트를 많이 추가하고 아름답고 우아한 코드를 작성하기 어렵게 만들기 때문이지만 어쨌든 해야 합니다. 중요한 고객이 422를 받았다고 불평할 때 그렇게 한 것을 후회할 것입니다. 고객이 뭔가 잘못했더라도 여전히 고객이 무엇을 잘못했는지 알아내야 합니다 .

시스템의 운영 부분에 대한 기본적인 관찰 가능성도 확보해야 합니다. 즉, 호스트 또는 컨테이너의 CPU/메모리, 대기열 크기, 요청당 또는 작업당 평균 시간 등을 파악해야 합니다. 요청당 시간과 같은 사용자 지표의 경우, p95 및 p99(즉, 가장 느린 요청의 속도)도 살펴봐야 합니다. 매우 느린 요청이 한두 개라도 발생하면 문제가 될 수 있습니다. 이러한 요청은 규모가 가장 크고 중요한 사용자로부터 불균형적으로 많이 발생하기 때문입니다. 평균값만 보면 일부 사용자가 서비스를 사용할 수 없다고 느낀다는 사실을 간과하기 쉽습니다.

## 🟠 킬스위치, 재시도 및 우아하게 실패
킬스위치에 대한 글을 여기서 반복하지 않고 대신 자세히 설명하겠습니다 . 요점은 시스템에 심각한 오류가 발생할 때 어떤 일이 일어나는지 신중하게 생각해야 한다는 것입니다.

재시도는 만병통치약이 아닙니다. 실패한 요청을 맹목적으로 재시도하여 다른 서비스에 과도한 부하를 주지 않도록 주의해야 합니다. 가능하다면 대량의 API 호출을 "서킷 브레이커"에 포함하세요. 5xx 응답이 연속으로 너무 많이 수신되면 서비스가 복구될 때까지 잠시 요청 전송을 중단하세요. 또한 성공 여부가 불분명한 쓰기 이벤트는 재시도하지 않도록 주의해야 합니다(예: "이 사용자에게 청구" 요청을 보냈는데 5xx 응답을 받았다면 해당 사용자에게 청구되었는지 알 수 없습니다 ). 이에 대한 고전적인 해결책은 "멱등 키"를 사용하는 것입니다. 멱등 키는 다른 서비스가 이전 요청을 재실행하지 않도록 요청의 특수 UUID입니다. 다른 서비스가 작업을 수행할 때마다 멱등 키를 저장하고, 동일한 키를 가진 다른 요청이 수신되면 자동으로 무시합니다.

시스템의 일부에 장애가 발생할 경우 어떻게 처리할지 결정하는 것도 중요합니다. 예를 들어, Redis 버킷을 검사하여 현재 창에서 사용자가 너무 많은 요청을 보냈는지 확인하는 속도 제한 코드가 있다고 가정해 보겠습니다. Redis 버킷을 사용할 수 없게 되면 어떻게 될까요? 두 가지 옵션이 있습니다. 장애 발생 시(Fail Open ) 요청을 허용하거나, 장애 발생 시(Fail Close) 429 오류로 요청을 차단하는 것입니다.

실패 시 열림(Fail Open) 또는 닫힘(Closed) 중 어떤 방식을 사용해야 할지는 기능에 따라 다릅니다. 제 생각에는 속도 제한 시스템은 거의 항상 실패 시 열림(Fail Open)을 보장해야 합니다. 즉, 속도 제한 코드에 문제가 발생하더라도 사용자에게 큰 사고로 이어지지는 않습니다. 하지만 인증 시스템은 (분명히) 항상 실패 시 닫힘(Fail Close)을 보장해야 합니다. 다른 사용자의 데이터에 대한 접근 권한을 부여하는 것보다 사용자 자신의 데이터에 대한 접근을 거부하는 것이 더 낫기 때문입니다. 어떤 방식이 올바른 동작인지 명확하지 않은 경우가 많습니다. 이는 종종 어려운 타협점입니다.

## 🟠 마지막 생각
여기서 일부러 다루지 않는 몇 가지 주제가 있습니다. 예를 들어, 모놀리스를 여러 서비스로 분할할지 여부와 시기, 컨테이너 또는 VM을 언제 사용해야 하는지, 추적, 좋은 API 설계 등이 있습니다. 제 경험상 모놀리스는 괜찮습니다. 또는 너무 당연해서 이야기하기 어렵다고 생각해서(추적을 사용하는 것이 좋습니다), 또는 시간이 부족해서(API 설계는 복잡합니다) 부분적으로는 이런 것들이 그다지 중요하지 않다고 생각하기 때문입니다.

제가 강조하고 싶은 핵심은 이 글 서두에서 말씀드린 것과 같습니다. 좋은 시스템 설계는 영리한 기술이 아니라, 지루하지만 충분히 검증된 구성 요소를 적절한 위치에 사용하는 방법을 아는 것입니다. 저는 배관공은 아니지만, 좋은 배관 작업도 이와 비슷하다고 생각합니다. 너무 흥분되는 일을 하다 보면 결국 엉망이 될 가능성이 높습니다.

특히 이러한 구성 요소가 이미 기성품으로 존재하는 대형 기술 기업(예: 회사에 이미 이벤트 버스, 캐싱 서비스 등이 있는 경우)의 경우, 좋은 시스템 설계는 아무것도 아닌 것처럼 보일 것입니다. 컨퍼런스에서 발표할 만한 시스템 설계를 하고 싶은 분야는 거의 없습니다. 물론 존재합니다! 저는 수작업으로 구현된 데이터 구조가 다른 방법으로는 불가능했을 기능을 구현하는 것을 보았습니다. 하지만 10년 동안 그런 일은 한두 번밖에 보지 못했습니다. 지루한 시스템 설계는 매일같이 보게 됩니다.

대신 타임스탬프를 저장하고, 타임스탬프가 있는 경우 .으로 처리해야 합니다 true. 저는 가끔 이렇게 하지만 항상 그런 것은 아닙니다. 제 생각에는 데이터베이스 스키마를 즉시 읽을 수 있도록 유지하는 것이 어느 정도 가치가 있다고 생각합니다.

---
↩
기술적으로 모든 서비스는 어떤 종류의 정보를 일정 기간 동안, 적어도 메모리에 저장합니다. 일반적으로 여기서는 요청-응답 라이프사이클 외부(예: 데이터베이스와 같이 디스크 어딘가에 영구적으로 저장)에 정보를 저장하는 것을 의미합니다. 애플리케이션 서버를 가동하는 것만으로 새 버전의 앱을 구축할 수 있다면, 그것은 상태 비저장 앱입니다.

↩
트위터의 게임 개발자들은 10ms보다 느린 반응 속도는 용납할 수 없다고 말합니다. 실제로 그렇게 해야 하는지는 모르겠지만, 성공적인 기술 제품에는 실제로 그렇지 않습니다. 사용자는 앱이 자신에게 유용한 기능을 제공한다면 느린 반응 속도도 감수할 것입니다.

↩
메인 서버처럼 데이터베이스와 통신할 필요가 없기 때문에 빠릅니다. 이론적으로는 디스크에 저장된 정적 파일을 요청 시 제공하거나, 심지어 메모리에 저장된 데이터일 수도 있습니다.

↩
그런데, 캐시 서버는 메인 서버를 폴링(즉, 풀링)하거나, 메인 서버가 캐시 서버로 새 데이터를 전송(즉, 푸싱)합니다. 어떤 방식을 사용하든 크게 상관은 없을 것 같습니다. 푸싱하면 최신 데이터를 얻을 수 있지만, 풀링이 더 간단합니다.

